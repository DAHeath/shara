\section{Generating a Minimal CDD Expansion}
\label{app:cons-cdd}
% algorithm for constructing a CDD system:
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a heap program and an error location.
  \Input{A recruions-free CHC system $S$.}
  % Output: inductive invariants.
  \Output{A minimal CDD expansion $S'$ of $S$ and
    correspondence from $S'$ to $S$.} %
  \myproc{$\expand(S)$ %
    \label{line:expand-begin} }{ %
    % auxiliary procedure:
    \myproc{$\expandaux(S')$
      \label{line:expand-aux-begin} }{ %
      % case split: optional sharing clause:
      \Switch{$\sharingclause(S')$}{ %
        % case: no siblings with overlapping descendants
        \lCase{$\none$:}{ \Return{$S'$} %
          \label{line:expand-ret} } %
        % case: siblings with 
        \lCase{$C \in S', % 
          P \in \predof{S'}$: }{ %
          % expand the return:
          \Return{$\expandaux( %
            \copyrel(S', C, P))$ } %
          \label{line:expand-recurse}
        } %
      } %
    \label{line:expand-aux-end} } %
    % base call: 
    \Return{$( \expandaux(S), \corr )$ %
      \label{line:expand-base-call}}
  } %
  %
  \caption{$\expand$:
    given a recursion-free CHC system $S$, returns a minimal
    CDD expansion $S'$ of $S$ and its correspondence.}
  \label{alg:expand}
\end{algorithm}
%
% walk through top-level procedure:
Given a recursion-free CHC system $S$, \autoref{alg:expand} returns a
minimal CDD expansion of $S$ (\autoref{defn:min-expansion}).
%
$\expand$ defines a procedure $\expandaux$
(\autoref{line:expand-aux-begin}---\autoref{line:expand-aux-end}) that
takes a CHC system $S$ and returns a minimal CDD expansion of $S$.
%
$\expand$ runs $\expandaux$ on $S$ and
returns the result, paired with the map $\corr: \predof{S'} \to \predof{S}$ 
(\autoref{line:expand-base-call}).

% walk through aux procedure:
$\expandaux$, given a recursion-free CHC system $S'$,
runs a procedure $\sharingclause$ on $S'$, which tries to
find a clause $C \in S'$ and a predicate $P \in \bodyof{C}$
such that $P$ is in the transitive dependencies of two sibling
predicates.
%
In such a case, we say that $(C, P)$ is a
\emph{sibling-shared dependency}.

% case: no sibling-shares
If $\sharingclause$ determines that no sibling-shared dependency
exists, then $\expandaux$ returns $S'$
(\autoref{line:expand-ret}).

% case: there is a sibling-shared dependency:
Otherwise, $\sharingclause$ must have located a sibling-shared
dependency $(C, P)$. In this case, $\expandaux$ runs $\copyrel $ on
$S'$, $C$, and $P$, which returns an expansion of $S'$ by creating a
fresh copy of $P$ and updating $\bodyof{C}$ to avoid the shared
dependency.
%
$\expandaux$ recurses on this expansion and returns the result
(\autoref{line:expand-recurse}).
%

% CDD systems:
$\expand$ always returns a CDD expansion of its input
(see \autoref{app:corr}, \autoref{lem:expand-corr}) that is minimal.
% discussion: there are variations:
$\expand$ is certainly not unique as an algorithm for
generating a minimal CDD expansion.
%
In particular, feasible variations of $\expand$ can be
generated from different implementations of $\sharingclause$, each of
which chooses clause-relations pairs to return based on different
heuristics.
%
We expect that other expansion algorithms can also be developed by
generalizing algorithms introduced in previous work on generating
compact verification conditions of hierarchical
programs~\cite{lal-qadeer15}.

\section{Proof of characterization of CDD systems}
\label{app:char}
The following is a proof of \autoref{thm:cdd-contains}.
%
\begin{proof}
  % proof structure:
  To prove that CDD is a strict superset of the union of the class
  of linear systems and the class of body-disjoint systems, we prove
  %
  \textbf{(1)} CDD contains the class of linear systems,
  \textbf{(2)} CDD contains the class of body-disjoint systems, and
  \textbf{(3)} there is some CDD system that is neither linear nor
  body-disjoint.

  % contains linear systems:
  For goal \textbf{(1)}, let $S$ be an arbitrary linear
  system.
  %
  $S$ is CDD if for each clause $C$ in
  $S$, each pair of distinct predicates in
  the body of $C$, the transitive dependencies are disjoint and
  no predicates appears more than once in the body of $C$.
  (\autoref{defn:cdds}).
  %
  Let $C$ be an arbitrary clause in $S$.
  %
  Since $C$ is a linear clause, it has at most one relational
  predicate in its body. Therefore, the transitive dependencies are
  trivially disjoint and there can be no repeated predicate.
  %
  Therefore, $S$ is CDD.

  % contains body-disjoint systems:
  For goal \textbf{(2)}, let $S$ be an arbitrary
  body-disjoint system.
  %
  The dependence relation of $S$ is a tree $T$, by the
  definition of a body-disjoint system.
  %
  Let $C$ be an arbitrary clause in $S$, with
  distinct relational predicates $R_0$ and $R_1$ in its body.
  %
  All dependencies of $R_0$ and $R_1$ are in subtrees of $T$, which
  are disjoint by the definition of a tree.
  %
  Thus, $S$ is CDD, by \autoref{defn:cdds}.

  % distinguishing example:
  For goal \textbf{(3)}, the system $\mcchc$ is CDD, but is neither linear
  nor body-disjoint.
\end{proof}

\section{Proof $\solvecdd$ is in co-NP}
\label{app:solve-cp}
The following is a proof of \autoref{thm:solve-cp}.
%
Namely, the upper bound of $\solvecdd$ is in co-NP.
%
\begin{proof}
  $\prectr$ and $\postctr$ construct formulas linear in the size of the
  CHC system. The satisfiability problem for the constructed formulas
  are in NP for linear arithmetic.
  %
  $\solvecdd$ at issues (at worst) a linear number of interpolation
  queries in terms of number of predicate.
  %
  Therefore, the upper bound of $\solvecdd$ is co-NP.
\end{proof}

\section{Proof of Correctness}
\label{app:corr}
%
In this section, we give a proof that \sys is a correct solver for
recursion-free CHC systems.
%
We first establish lemmas for the correctness of each procedure used
by \sys, namely \textsc{Collapse} (\autoref{lem:expansion-sound} and
\autoref{lem:expansion-complete}), $\expand$
(\autoref{lem:expand-corr}), and $\solvecdd$
(\autoref{lem:vc}, \autoref{lem:cdd-soln-sound}, and
\autoref{lem:cdd-soln-complete}).
%
We combine the lemmas to prove correctness of \sys
(\autoref{thm:corr}).

% lem: result connecting expansions to constructing solutions
For recursion-free CHC systems $S$ and $S'$, if $S'$ is
an expansion of $S$, then the result of collapsing a
solution of $S'$ is a solution of $S$.
%
\begin{lem}
  \label{lem:expansion-sound}
  For recursion-free CHC system $S'$ and $S$,
  $\sigma'$ is a solution of $S'$, and $\eta : \predof{S}' \to
  \predof{S}$ a correspondence from $\predof{S}'$ to $\predof{S}$,
  $\collapse{\eta}{\sigma'}$ is a solution of $S$.
\end{lem}
%
\begin{proof}
  % introduce 
  Let $\mathcal{B} \in \bodies{\mathcal{R}}$, $\varphi \in \formulas$,
  and $R \in \mathcal{R}$ be such that $((\mathcal{B}, \varphi),
  R(\vars{ \mathcal{S} }(R))) \in \mathcal{S}$.
  %
  For each predicate $P' \in \predof{S}'$ such that $\eta(P') = P$, there is
  some clause $C' \in S'$ such that $P' \in \bodyof{C'}$ by the fact that $S'$ is an expansion of
  $S$ and the definition of an expansion.
  %
  Let preicate $Q' \in \predof{S}'$ such that $Q'$ is the head of clause $C'$.
  % 
  $\sigma'[P'] \land \consof{C'} \entails \sigma'[Q']$ by
  the fact that $\sigma'$ is a solution of $S'$.
  %
  Therefore,
  %
  \[ \collapse{ \eta }{ \sigma' }[P] \land \consof{C'} \entails %
  \left( \bigland_{ \substack{Q' \in \predof{S}' \\ \eta(Q') = Q} }
  \sigma(Q') = %
  \collapse{\eta}{\sigma'}[Q'] \right)
  \]
  % 
  Therefore, $\collapse{\eta}{\sigma'}$ is a solution of $P$.
  %
  Therefore, $\collapse{\eta}{\sigma'}$ is a solution of
  $S$.
\end{proof}

% completeness of expansions:
For a recursion-free CHC system $S$ is solvalbe, each expansion of $S$
is solvable.
\begin{lem}
  \label{lem:expansion-complete}
  For a recursion-free CHC system $S$ is solvable, and
  $S'$ is
  an expansion of $S$, $S'$ is solvable.
\end{lem}
%
\begin{proof}
  Let $\sigma : P \to \formulas$ be a solution of
  $S$, and let $\eta : \predof{S}' \to \predof{S}$ be a
  correspondence from $S'$ to $S$.
  %
  Let $\sigma' : \predof{S}' \to \formulas$ be such that for each $P'
  \in \predof{S}'$, $\sigma'(P') = \sigma(\eta(P'))$.
  %
  Then $\sigma'$ is a solution of $S'$.
\end{proof}

% CDD systems:
$\expand$ always returns a CDD expansion of its input.
%
\begin{lem}
  \label{lem:expand-corr}
  For a recursion-free CHC system $S$ and $S'$, and $\eta : \predof{S'} \to \predof{S}$ such that
  $(S', \eta) = \expand(S)$, $\eta$
  is a correspondence from $S'$ to $S$, $S'$ is an CDD system and an expansion
  of $S$.
\end{lem}
%
\begin{proof}
  Proof by induction on the evaluation of $\expand$ on
  an arbitrary recursion-free CHC system $S$.
  % inductive fact:
  The inductive fact is that in each step of evaluation \expandaux,
  $\corr$ is a correspondence from argument
  $S'$ to $S$.
  % base case:
  For the base case, \expandaux is called initially on $S$,
  by \autoref{alg:expand}.
  % 
  $\corr$ is a correspondence from $S$ to
  itself, by the definition of $\corr$
  (\autoref{app:cons-cdd}).

  % inductive case:
  For the inductive case, for $C \in S$ and $P \in \predof{S}$, $\expandaux$ calls itself on 
  $\copyrel(S, C, P)$.
  %
  For each recursion-free CHC system $S'$ that generated by $\copyrel(S, C, P)$,
  $\corr$ is a correspondence from $S'$ to
  $S$ by definition of $\copyrel$
  (\autoref{app:cons-cdd}).
  %
  By this fact and the inductive hypothesis, $\corr$ is
  a correspondence from $\copyrel(S',
  C, P)$ to $S$.

  % final claim: expand returns an expansion:
  $\expandaux$ returns its parameter at some step, by
  \autoref{alg:expand}.
  %
  Therefore, $\expandaux$ returns an expansion of $S$.

  % prove that returned system is CDD:
  For a given recursion-free CHC system $S'$, if $(S', \eta) =
  \expand(S')$, 
  then $\sharingclause(S') = \none$, by the definition of $\expand$.
  %
  If $\sharingclause(S') = \none$, then $S'$ is
  CDD, by the definition of $\sharingclause$ and CDD systems
  (\autoref{defn:cdds}).
  %
  Therefore, $S'$ is CDD.
\end{proof}
%
Furthermore, $\expand$ returns a \emph{minimal} CDD
expansion of its input.
%
This fact is not required to prove \autoref{thm:corr}, and thus a
complete proof is withheld.

% lem: VC's characterize system sat:
For each recursion-free CHC system $S$, $S$ has a solution if and
only if all interpolants queries return interpolants.
%
\begin{lem}
  \label{lem:vc}
  Given a recursion-free CHC system $S$ that is CDD and solvable, for all predicates $P \in \predof{S}$,
   $\solveitp(\prectr(\cc{P},\sigma),\postctr(\cc{P},\sigma))$ returns a interpolatn $I$.
\end{lem}
%
\begin{proof}
  %
  Assume that $S$ has solution $\sigma$ and there are
  some predicates $P \in \predof{S}$ such that $\solveitp(\prectr(\cc{P},\sigma'),\postctr(\cc{P},\sigma'))$
  returns $SAT$, which means there is a model $m$ for the conjuntion of $\prectr(\cc{P},\sigma')$
  and $\postctr(\cc{P},\sigma')$.
  %
  But $\postctr(\cc{P},\sigma) = \false$, by the definition of
  a solution of a CHC system.
  %
  Therefore, there can be no such model $m$.
  %
  Therefore, $\solveitp(\prectr(\cc{P},\sigma'),\postctr(\cc{P},\sigma'))$ always returns interpolant.
\end{proof}

\begin{lem}
  \label{lem:solve-aux}
  Given a recursion-free CHC system $S$ that is CDD, if for all predciates $P \in \predof{S}$, 
  $\solveitp(\prectr(\cc{P},\sigma),\postctr(\cc{P},\sigma))$ returns a interpolatn $I$, 
  then $\solvecdd(S)$ is a solution of $S$.
\end{lem}
%
\begin{proof}
  % overview of structure:
  Proof by induction on the $\solvecdd(S)$ calles $\solveitp$ on all predicates $P \in \predof{S}$
  in a topolgical order.
  %
  The inductive fact is that at each step of calling $\solveitp$, $\sigma$ is a
  partial solution of $S$.
  % base case:
  For the base case, $\predof{S} = \varnothing$,
  %
  Therefore, $\sigma$ is a solution of $S$.

  % inductive case:
  For the inductive case, in each step, $\solvecdd$ calls $\solveitp$ on
  a predicate $P \in \predof{S}$ with partial solution $\sigma$, which
  contains all solutions of predciates $P \in \depsof{S}$.
  %
  Based on the definition of an interpolant(\autoref{defn:itps}), $\sigma$
  is a partial solution of $S$, then $\prectr(\cc{P},\sigma')$ and $\postctr(\cc{P},\sigma))$
  are inconsistent.
  %
  The interpolant $I$ returns by $\solveitp(\prectr(\cc{P},\sigma),\postctr(\cc{P},\sigma))$ entails
  by all clause that head is $P$ and $\bodyof{P}$ is substituted by partial solution $\sigma$.
  %
  $I$ also is inconsistment with all constrains shows later that support the query clause.
  %
  Then $\solvecdd$ updates $\sigma$ by binding $P$ to $I$, which makes the new $\sigma$ also a partial
  solution of $S$.

  %
  Base case combined with the inductive case, imply that \solvecdd
  returns a solution of $S$.
\end{proof}

% SolveCDD: establish soundness
$\solvecdd$ is a
correct CHC solver for CDD systems $S$.
%
\begin{lem}
  \label{lem:cdd-soln-sound}
  For a given CDD system $S$, and $\sigma = \solvecdd(S)$, %
  $\sigma$ is a solution of $\mathcal{S}$.
\end{lem}
%
\begin{proof}
  %
  $\solvecdd{S}$ returns $\sigma$ implies that for all predicates 
  $P \in \predof{S}$, $\solveitp(\prectr(\cc{P},\sigma),\postctr(\cc{P},\sigma))$ returns a interpolatn $I$, 
  by the definition of $\solvecdd$ \autoref{alg:solve-cdd}. 
  %
  Therefore, \autoref{lem:solve-aux} implies that \solvecdd
  returns a complete solution of $S$.
\end{proof}

% SolveCDD: establish completeness
\begin{lem}
  \label{lem:cdd-soln-complete}
  For a CDD system $S$ such that $S$ is
  solvable, %
  there is some $\sigma$ such that %
  $\sigma = \solvecdd(S)$.
\end{lem}
%
\begin{proof}
  % final claim:
  for all predicates $P \in \predof{S}$, $\solveitp(\prectr(\cc{P},\sigma),\postctr(\cc{P},\sigma))$ returns a interpolatn $I$, by
  \autoref{lem:vc} and the fact that $\mathcal{S}$ is solvable.
  %
  Therefore, by \autoref{lem:solve-aux} and the fact that
  $S$ is solvable, $\solvecdd(S)$ returns a
  solution of $S$.
\end{proof}

% proof of main theorem:
The following is a proof of correctness of \sys
(\autoref{sec:approach}, \autoref{thm:corr}).
%
\begin{proof}
  Given recurion-free CHC systems $S$ and $S'$, and $\eta :\predof{S'} \to 
  \predof{S}$ such that $(S', \eta) = \expand(S)$, 
  then $S'$ is minimal CDD expansion of 
  $S$, and $\eta$ is a correspondence from $S'$ to $S$ by \autoref{lem:expand-corr}.
  %
  There is some $\sigma'$ such that
  $\sigma' = \solvecdd(S' )$, by
  the definition of $\shara$.
  %
  $\sigma'$ is a solution of $S'$, by
  \autoref{lem:cdd-soln-sound}.
  %
  $\collapse{ \eta }{ \sigma' }$ is a solution of $S$, by
  \autoref{lem:expansion-sound}.

  % if S is solvable, then shara returns a solution
  Assume that a recursion-free $S$ is solvable.
  %
  Let a recursion-free CHC system $S'$ and $\eta :
  \predof{S'} \to \predof{S}$ be such that $(S',
  \eta) = \expand(S)$.
  %
  $S'$ is a CDD expansion of $S$, by
  \autoref{lem:expand-corr}.
  %
  $S'$ is solvable, by \autoref{lem:expansion-complete}.
  %
  $\solvecdd(S')$ returns a solution $\sigma$ of $S'$ by \autoref{lem:cdd-soln-complete}.
  %
  $\shara$ returns a solution of $S$ by calling $\collapse{ \eta }{ \sigma' }$, based on
  \autoref{alg:shara}.
\end{proof}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
