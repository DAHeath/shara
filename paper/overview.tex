\section{Overview}
\label{sec:overview}

%first introduce the question
In \autoref{sec:running-ex}, we describe a recursion-free CHC system,
$\mcchc$, that formulates verifying the safety of the program
\cc{multiCall} (\autoref{fig:multicall-code}).
%
In \autoref{sec:solve-ex}, we show that $\mcchc$ is a
\emph{Clause-Dependent Disjoint (CDD)} system and how \sys can solve it by 
encoding it into binary interpolants.
%
In \autoref{sec:not-in}, we illustrate that
$\mcchc$ is not in the directly solvable classes introduced in
previous work.
%


% introduce running example program
\subsection{Verifying \cc{multiCall}: an example hierarchical program}
\label{sec:running-ex}

\QZ{remake the graph}
% include code of running example and some figure:
\begin{figure}[t]
  \centering
  \begin{floatrow}[2]
    \ffigbox[.26\textwidth] %
    { \caption{\cc{multiCall}: an example hierarchical program.} %
      \label{fig:multicall-code} }
    { \input{code/multiCall.java} }
    %
    \ffigbox[.7\textwidth] %
    {\caption{Dependencies of CHC system $\mcchc$, depicted as a
        hypergraph.
        % 
        Each relational predicate is a node (circle) and each clause
        is a hyperedge (box). } %
      \label{fig:ex-deps} }
    { \includegraphics[width=\linewidth]{fig/ex-deps.pdf} }
  \end{floatrow}
\end{figure}
% walk through code of running example:
%
\cc{multiCall} includes a procedure \cc{db} that, given an integer
variable \cc{m}, returns the value of \cc{m} doubled (line 1).
%
\cc{main}, the entry procedure of \cc{multiCall}, given integer \cc{n}
(line 3), first binds variable \cc{abs} to $0$ (line 4).
%
\cc{main} tests if \cc{n} is greater than or equal to $0$ (line
5).
%
If so, \cc{main} binds the value of \cc{n} to \cc{res} (line 6).
%
If not, \cc{main} binds the negation value of \cc{n} to \cc{res} (line 8).
%
\cc{main} then calles \cc{dbl} on \cc{abs} and binds the return value to \cc{res} (line 9)
%
\cc{main} then returns the value stored in \cc{res} (line 10).

% state the safety problem:
The property to be verified in \cc{multiCall} is, for each input, 
\cc{multiCall}
returns a value greater than or equal to $0$.
% talk about solving Horn Clauses:
Verifying that \cc{multiCall} satisfies such a property can be reduced
to solving a recursion-free CHC system over a set of uninterpreted predicates
that each represents a control location and
procedure name in \cc{multiCall}.
%
In particular, one such system $\mcchc$ is
%
\QZ{left allign}
\begin{gather}
\label{chc}
  % semantic constraint of dbl:
  \cc{db}(\cc{m}, \cc{d}) \gets \cc{d} = 2 * \cc{m} \\
  % semantic constraint of line 3:
   \cc{L4}(\cc{n}, \cc{abs}) \gets  \cc{abs} = 0 \\
  % semantic constraint of line 5 (then branch)
   \cc{L6}(\cc{n}, \cc{abs}) \gets \cc{L4}(\cc{n}, \cc{abs}) \land \cc{n} \ge 0 \\
  % semantic constraint of line 6 (else branch)
   \cc{L8}(\cc{n}, \cc{abs}) \gets \cc{L4}(\cc{n}, \cc{abs}) \land \cc{n} < 0 \\
  % assign branch
   \cc{L9}(\cc{n}, \cc{abs'}) \gets \cc{L6}(\cc{n},\cc{abs}) \land \cc{abs'} = \cc{n} \\
   \cc{L9}(\cc{n}, \cc{abs'}) \gets \cc{L8}(\cc{n},\cc{abs}) \land \cc{abs'} = -\cc{n} \\
  % semantic constraint of main procedure:
    \cc{main}(\cc{n},\cc{res}) \gets \cc{L9}(\cc{n}, \cc{abs'}) \land \cc{db}(\cc{m}, \cc{d})
    \land \cc{abs'} = \cc{m} \land \cc{res} = \cc{d} \\
  %
   False \gets \cc{main}(\cc{n}, \cc{res}) \land \cc{res} < 0 
\end{gather}
%
While $\mcchc$ has been presented as the result
of a translation from hierarchical program \cc{multiCall}, \sys is
purely a solver for CHC systems: it does not require access to the
concrete representation of a program, or for a given CHC system to be
the result of translation from a program at all.

% solving the running example
\subsection{\cc{multiCall} as a Clause-Dependent Disjoint system}
\label{sec:solve-ex}
% state it is CDD
The recursion-free CHC system \cc{multiCall} is a \emph{Clause-Dependent-Disjoint (CDD)}) system.
% state the defn of CDD:
\emph{Clause-Dependent-Disjoint (CDD)}) system is an recursion-free CHC system such that
for any uninterpreted predictes in the body of the same clause, their transitive dependencies
are disjoint(i.e,they do not have common predicates).
%
The formal definition of CDD and its key properties are given in
\autoref{sec:CDD-defn}.

% give a example
In particular, for clause $(7)$, uninterpreted predicates \cc{L6} and \cc{db} shows in
the body of same clause.
%
The transitive dependency of \cc{L6} is \{\cc{L6}\,\cc{L8}\,\cc{L4}\}, 
and the transitive dependency of \cc{db} is $\varnothing$.
%
Their transitive dependencies are disjoint, because \{\cc{L6}\,\cc{L8}\,\cc{L4}\} $\cap \varnothing = \varnothing$.
%
The formal definition of transitive dependency is given in\QZ{reference}.
%
And the other clauses in \cc{multiCall} only has one uninterpreted predicates in the body, so
\cc{multiCall} is a CDD system.
%
The fact that $\mcchc$ is CDD corresponds to the fact that there no statements executed more than
once within one execution path.
%

% restate defn of CDD systems:
\sys solves $\mcchc$ directly by issuing a binary 
interpolation queriey for each uninterpreted predicates in $\mcchc$ in a topological order.
%
For each uninterpreted predicate $P$ in $\mathcal{S}$, the solution of
$P$ is the interpolant of two formulas: %
\textbf{(1)} a \emph{pre}-formula, constructed as 
the solution of each uninterpreted predicate in dependence of $P$, constraints
in corresponding clauses and boolean indicator variable for 
each uninterpreted predicates in $\mcchc$%
\textbf{(2)} a \emph{post}-formula, constructed as  
all constraints that occur after $P$ and boolean indicator variable for 
each uninterpreted predicates in $\mcchc$.
%

% walk through the example
E.g., when \sys solving $\mcchc$, \sys issues interpolation queries of 
each uninterpreted predicates in the order \cc{L4}, \cc{L6}, \cc{L8}, 
\cc{L9}, \cc{db} and \cc{main}.
%
In particular, when \sys issues interpolation query for uninterpreted predicates \cc{L9},
\sys has generated solutions for \cc{L4}, \cc{L6}, \cc{L8} which shows in\QZ{refer to graph}.
%

The solution of \cc{L9} is an interpolant of \textbf{(1)} 
a \emph{pre}-formula, constructed as solutions generated for \cc{L4}, \cc{L6}
the constraints in clauses (5) and (6) and boolean variables%
\textbf{(2)} a \emph{post}-formula constructed from constraints in
$\mcchc$ that all constrains after \cc{L9}, constrains for \cc{db}
and boolean variables.
%
In particular, the \emph{pre}-formula for \cc{L9} is 
\begin{gather}
((b_{L8}\land abs'= -n) \lor (b_{L6} \land abs=n))\land (\neg b_{L6} \lor n \ge 0) \land (\neg b_{L8} \lor n<0)
\end{gather}
%
, $b_{L8}$ and $b_{L6}$ are boolean variables corresponding to predicates \cc{L8} and \cc{L6}.
%
The \emph{post}-formula for \cc{L9} is
\begin{gather}
(b_{main} \land res' < 0 ) \land (\neg b_{main} \lor (b_{db} \land abs'= m \land res =d )) 
\land (\neg b_{db} \lor d = 2*m)
\end{gather}
, $b_{main}$ and $b_{db}$ are boolean variables corresponding to predicates \cc{main} and \cc{db}.
%
A detailed and formal description for the procedure of solving a CDD system is given in
\autoref{sec:solve-cdd}.


\subsection{\cc{multiCall} is not in other system}
\label{sec:not-in}
%
There are three classes of directly solvable systems has been introduced
in previous work(as described in \autoref{sec:intro}).
%
However, $\mcchc$ does not belong to any of these three classes.
%

% tree solver 
In particular, previous work has introduced tree structure systems\cite{bjorner13,heizmann10},
which each uninterpreted predicate in the system is the head of at most one clause.
%
Such systems do not include $\mcchc$, because predicate \cc{L9} is the head 
of clause (5) and (6).
%
CHC solvers based on tree structure system has to reduce solving $\mcchc$ to
solving two tree strucutre systems that contains by $\mcchc$, that one corresponds
to the tree branch and the other corresponds to the false branch.
% not that bad 
There are works has been proposed which in some cases enumerating 
and solving all derivation trees 
of a given recursion-free
system~\cite{mcmillan14}.
%
However, such solvers may enumerate all derivations tree of a given system
in the worst case.

% Body-Disjoint:
Previous work has introduced \emph{body-disjoint}
systems~\cite{rummer13a,rummer13b}, 
which each uninterpreted predicate shows in the body of at most one
clause, and shows in the body of such a clause at most once;
%
However, such systems cannot model a program with multiple
control paths that share a common subpath, typically modeled as a CHC
system with a uninterpreted predicate that occurs in the body of multiple clauses.
%
$\mcchc$ is not a body-disjoint system because the uninterpreted
predicates \cc{L4} shows in the body of both clauses (3) and (4).
%
Such a solver, given $\mcchc$, generates a body-disjoint system
consisting of two copies of the sub-systems with head relational
predicates \cc{L4}.

%linear systems:
Previous work also introduced linear system~\cite{albarghouthi12a}, 
which each clause's body has at most one uninterpreted predicate.
%
However, such systems cannot directly model the control flow of a
program that contains procedure calls.
%
$\mcchc$ is not a linear system because the body of clause (7) has two
predicates \cc{L9} and \cc{db}.
%
CHC solvers that solve linear systems, $\mcchc$, effectively inline constraints on
relational predicates that occur in non-linear clauses~\cite{albarghouthi12b}.
%
Such approaches can, in general, generate an inlined system that is
exponentially larger than a given system.

%% talk about expansion:
The class of CDD systems strictly contains these three classes, 
but does not contain all
recursion-free systems.
%
E.g., a recursion-free system that models \cc{multiCall} 
call \cc{dbl} twice on \cc{abs} in sequence would not
be CDD.
%
\sys, given an arbitrary recursion-free CHC system $S$,
solves it by generating an equivalent CDD system $S'$ and
solving $S'$ directly.
%
In general, $S'$ may have size exponential in the size of
$S$.
%
In practice, a suitable equivalent system can be generated using
heuristics analogous to those used to generate compact verification
conditions of hierarchical programs~\cite{flanagan01,lal-qadeer15}.
%
A general procedure for constructing a CDD expansion of a given CHC
system is given in \autoref{app:cons-cdd}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
