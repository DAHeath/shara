\section{Overview}
\label{sec:overview}

%first introduce the question
In \autoref{sec:running-ex}, we describe a recursion-free CHC system,
$\mcchc$, that formulates verifying the safety of the program
\cc{multiCall} (\autoref{fig:multicall-code}).
%
In \autoref{sec:solve-ex}, we show that $\mcchc$ is a
\emph{Clause-Dependent Disjoint (CDD)} system and how \sys can solve it by 
encoding it into binary interpolants.
%
In \autoref{sec:not-in}, we illustrate that
$\mcchc$ is not in the directly solvable classes introduced in
previous work.
%


% introduce running example program
\subsection{Verifying \cc{multiCall}: an example hierarchical program}
\label{sec:running-ex}

\QZ{remake the graph}
% include code of running example and some figure:
\begin{figure}[t]
  \centering
  \begin{floatrow}[2]
    \ffigbox[.26\textwidth] %
    { \caption{\cc{multiCall}: an example hierarchical program.} %
      \label{fig:multicall-code} }
    { \input{code/multiCall.java} }
    %
    \ffigbox[.7\textwidth] %
    {\caption{Dependencies of CHC system $\mcchc$, depicted as a
        hypergraph.
        % 
        Each relational predicate is a node (circle) and each clause
        is a hyperedge (box). } %
      \label{fig:ex-deps} }
    { \includegraphics[width=\linewidth]{fig/ex-deps.pdf} }
  \end{floatrow}
\end{figure}
% walk through code of running example:
%
\cc{multiCall} includes a procedure \cc{dbl} that, given an integer
variable \cc{n}, returns the value of \cc{n} doubled (line 1).
%
\cc{main}, the entry procedure of \cc{multiCall}, given integer \cc{n}
(line 3), first binds variable \cc{res} to $0$ (line 4).
%
\cc{main} then tests if \cc{n} is greater than or equal to $0$ (line
5).
%
If so, \cc{main} doubles the value in \cc{n} and binds the result to
\cc{res} (line 6).
%
If not, \cc{main} doubles the value in \cc{n}, negates the result, and
binds the final result to \cc{res} (line 8).
%
\cc{main} then returns the value stored in \cc{res} (line 9).

% state the safety problem:
The problem that we address in this work, in the context of
\cc{multiCall}, is to verify that for each input, \cc{multiCall}
returns a value greater than or equal to $0$.
% talk about solving Horn Clauses:
Verifying that \cc{multiCall} satisfies such a property can be reduced
to solving a recursion-free CHC system over a set of uninterpreted predicates
$\mcpreds$ that each represents a control location and
procedure name in \cc{multiCall}.
%
A solution interprets each control location \cc{L} as a summary that
relates the arguments in each active call of the function containing
\cc{L} to the program state at \cc{L}, and interprets each procedure
name \cc{f} as a summary of \cc{f}.
%
For each step of \cc{multiCall} to \cc{L}, there is a corresponding
clause with head predicate \cc{L}.
%
For each procedure \cc{f}, there is a clause relating state at return
locations of \cc{multiCall} to a summary of their procedure.
%
In particular, one such system $\mcchc$ is
%
\QZ{left allign}
\begin{gather}
  % semantic constraint of dbl:
  \cc{dbl}(\cc{n}, \cc{res}) \gets \cc{res} = 2 * \cc{n} \\
  % semantic constraint of line 3:
   \cc{L4}(\cc{n}, \cc{res}) \gets  \cc{L3}(\cc{n}) \land \cc{res} = 0 \\
  % semantic constraint of line 5 (then branch)
   \cc{L9}(\cc{n}, \cc{res'}) \gets \cc{L4}(\cc{n}, \cc{res}) \land \cc{dbl}(\cc{n}, \cc{res}') \land
   \cc{n} \geq 0 \\
  % semantic constraint of line 6 (else branch)
   \cc{L9}(\cc{n}, \cc{res_1}) \gets \cc{L4}(\cc{n}, \cc{res}) \land \cc{dbl}(\cc{n}, \cc{res_0}) \land
   \cc{n} < 0  \land \cc{res_1} = -\cc{res_0} \\
  % semantic constraint of main procedure:
   False \gets \cc{L9}(\cc{n}, \cc{res}) \land \cc{res} < 0 
\end{gather}
%
While $\mcchc$ has been presented as the result
of a translation from hierarchical program \cc{multiCall}, \sys is
purely a solver for CHC systems: it does not require access to the
concrete representation of a program, or for a given CHC system to be
the result of translation from a program at all.

% solving the running example
\subsection{\cc{multiCall} as a Clause-Dependent Disjoint system}
\label{sec:solve-ex}
% state it is CDD
The recursion-free CHC system \cc{multiCall} is a \emph{Clause-Dependent-Disjoint (CDD)}) system.
% state the defn of CDD:
\emph{Clause-Dependent-Disjoint (CDD)}) system is an recursion-free CHC system such that
for any puninterpreted predictes in the body of the same clause, their transitive dependencies
are disjoint(i.e,they do not have common predicates).
%
The formal definition of CDD and its key properties are given in
\autoref{sec:CDD-defn}.
% give a example
In particular, for clauses $(3)$ and $(5)$, uninterpreted predicates \cc{L4} and \cc{dbl} shows in
the body of same clause.
%
The transitive dependency of \cc{L4} is \{\cc{L3}\}, and the transitive dependency of \cc{dbl}
is $\varnothing$.
%
Their transitive dependencies are disjoint, because \{\cc{L3}\} $\cap \varnothing = \varnothing$.
%
The formal definition of transitive dependency is given in\QZ{reference}.
%
And the other clauses in \cc{multiCall} only has one uninterpreted predicates in the body, so
\cc{multiCall} is a CDD system.
%
The fact that $\mcchc$ is CDD corresponds to the fact that there no statements executed more than
once in one execution path.
%

% restate defn of CDD systems:
\sys solves $\mcchc$ directly by issuing a binary 
interpolation queriey for each uninterpreted predicates in $\mcchc$ in a topological order.
% walk through how a CDD system is solved directly:
A solution of an arbitrary CDD system $\mathcal{S}$ can be constructed
from the results of a series of interpolation queries, each one issued
to find an interpretation of a relational predicate of $\mathcal{S}$
in the topological order of dependences between relational predicates.
%
For relational predicate $R$ in $\mathcal{S}$, the interpretation of
$R$ is the interpolant of two formulas: %
\textbf{(1)} a Boolean combination of the interpretations found for
each dependence of $R$ in $\mathcal{S}$ and constraints in
$\mathcal{S}$ and %
\textbf{(2)} a Boolean combination of constraints that occur in
$\mathcal{S}$.

% talk performance:
The performance of the solver is thus largely determined by the
ability of the interpolating theorem prover that it uses \textbf{(1)}
to generate interpolants quickly and %
\textbf{(2)} to generate interpolants of size close to that of their
input formulas.
%
In the worst case, all interpolating theorem provers given in previous
work may use exponential time to generate interpolants of size
exponential in the size of their inputs.
%
However, when given formulas that model practical verification
problems, modern theorem provers generate interpolants efficiently,
which have size close to the size of the given formulas.

% walk through multiCall
E.g., when solving $\mcchc$, \sys generates interpretations of
relational predicates in the order \cc{L3}, \cc{L4}, \cc{dbl},
\cc{L9}, and \cc{main}.
%
It generates an interpretation of \cc{L9} in particular as the
interpolant of \textbf{(1)} a \emph{pre}-formula, constructed as a
Boolean combination of interpretations generated for \cc{L4}, \cc{dbl}
and the constraints in \autoref{eqn:then} and \autoref{eqn:else} and %
\textbf{(2)} a \emph{post}-formula constructed from constraints in
$\mcchc$ that model the steps of execution of \cc{multiCall} following
\cc{9}.
%
A procedure for solving a CDD system directly is given in
\autoref{sec:solve-cdd}.

% talk about expansion:
The class of CDD systems strictly contains all directly-solvable
classes introduced in previous work, but does not contain all
recursion-free systems.
%
E.g., a recursion-free system that models \cc{multiCall} mutated to
call \cc{dbl} in sequence, instead of in alternate branches, would not
be CDD.
%
\sys, given an arbitrary recursion-free CHC system $\mathcal{S}$,
solves it by generating an equivalent CDD system $\mathcal{S}'$ and
solving $\mathcal{S}'$ directly.
%
In general, $\mathcal{S}'$ may have size exponential in the size of
$\mathcal{S}$.
%
In practice, a suitable equivalent system can be generated using
heuristics analogous to those used to generate compact verification
conditions of hierarchical programs~\cite{flanagan01,lal-qadeer15}.
%
A general procedure for constructing a CDD expansion of a given CHC
system is given in \autoref{app:cons-cdd}.

\subsection{\cc{multiCall} is not in other system}
\label{sec:not-in}
% walk through the zoo of CHC systems:
Competitive solvers of recursion-free CHC systems reduce the problem
of solving a given CHC system $\mathcal{S}$ to solving multiple
systems, constructed as copies of sub-systems of $\mathcal{S}$, each
of which is directly solvable (as described in \autoref{sec:intro}).
%
In particular, CHC solvers based on tree interpolation reduce solving
$\mathcal{S}$ to solving copies of subsystems of $\mathcal{S}$ in
which each relational predicate in $\mathcal{S}$ is the head of at
most one clause~\cite{bjorner13,heizmann10}.
%
Such systems do not include $\mcchc$, which contains multiple clauses
with the same head.

% consequences for solvers:
As a result, CHC solvers that synthesize tree interpolants may, in the
worst case, solve systems that correspond to each derivation of a
given CHC system.
%
Such solvers, given $\mcchc$, would solve it by generating two
tree-interpolation problems, one of which corresponds to the \cc{then}
branch of \cc{multiCall} and the other which corresponds to the
\cc{else} branch of \cc{multiCall}.
%
CHC solvers have been proposed which can in many cases avoid
enumerating and solving all derivation trees of a given recursion-free
system~\cite{mcmillan14}.
%
However, such solvers may enumerate all derivations of a given system
in the worst case.

% Body-Disjoint: 
CHC solvers that synthesize disjunctive interpolants reduce solving a
given recursion-free system to solving a series of CHC systems in
which each relational predicate occurs in the body of at most one
clause, and occurs in the body of such a clause at most once;
%
such systems are referred to as \emph{body-disjoint}
systems~\cite{rummer13a,rummer13b}.
%
However, such systems cannot compactly model a program with multiple
control paths that share a common subpath, typically modeled as a CHC
system with a relational predicate that occurs in multiple clauses
(i.e., a relational predicate that is \emph{shared}).
%
E.g., $\mcchc$ is not a body-disjoint system because the relational
predicates \cc{L4} and \cc{dbl} occur in both clauses
\autoref{eqn:then} and \autoref{eqn:else}.

% consequences for relational predicates:
CHC solvers that solve body-disjoint systems, given a general recursion-free CHC system,
generate multiple copies of sub-systems that body has shared
relational predicates.
%
Such a solver, given $\mcchc$, generates a body-disjoint system
consisting of multiple copies of the sub-systems with head relational
predicates \cc{L4} and \cc{dbl}.

% solving linear systems:
CHC solvers that synthesize DAG interpolants~\cite{albarghouthi12a}
reduce the problem of solving a given CHC system to solving a series
of systems in which each clause contains at most one relational
predicate (i.e., \emph{linear} systems).
%
However, such systems cannot directly model the control flow of a
program that contains procedure calls, such as \cc{multiCall}.
%
Calls can only be compactly modeled using non-linear clauses, such as
clauses \autoref{eqn:then} and \autoref{eqn:else}.

% solvers based on linear systems:
CHC solvers that solve linear systems, given an arbitrary
recursion-free system $\mathcal{S}$, effectively inline constraints on
relational predicates that occur in non-linear clauses of
$\mathcal{S}$~\cite{albarghouthi12b}.
%
Such approaches can, in general, generate an inlined system that is
exponentially larger than a given system.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
