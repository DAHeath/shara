We thank the reviewers for their detailed comments. Responses are
included below, where each summarized comment is labeled with the
reviews that contained it. Each of the points will be addressed in a
future version of the paper.

---------------------------------------------------------------------

Q1 (Reviews 1, 2, 3): This paper appears to only reproduce known
approaches that construct a body-disjoint CHC system and solve it
efficiently.

A: SHARA indeed resembles previous work in that it uses cloning to
generate a CHC system that can be solved efficiently. However, in this
work, we have introduced the class of Clause-Dependence Disjoint (CDD)
systems. To the best of our knowledge, the class of systems has not
been considered in previous work, and strictly contains the class of
body-disjoint systems.

In particular, a system is body disjoint if each relational predicate
R occurs in the body of at most one clause, and occurs in any clause
at most once ([16], Sec. 4.1, Defn. 3). A system is CDD if, for each
clause, the dependencies of each predicate that occur in the body of
the clause are disjoint (submission, Sec. 4, Defn. 7). The fact that
the class of body-disjoint systems is contained by the class of CDD
systems follows fairly directly from their definitions; we will
provide a detailed proof in a future version of this paper.

The following is a system that is not body disjoint but is CDD:

x = 0 => R1(x)
x > 0 => R2(x)
x < 0 => R4(x)
R1(x), R2(x) => R3(x)
R1(x), R4(x) => R3(x)

As a more practical example, the system S'[MC] (Sec. 2.2) is not body
disjoint, but is CDD.

The work on body-disjoint systems is indeed relevant, and we will
discuss it in greater detail in a future version of the paper.

-------------------------------------------------------------------- 

Q2 (Reviews 1, 2, 3): How did you choose the benchmarks on which you
evaluated SHARA? How did you convert SV-COMP benchmarks to CHC
systems?

A: We evaluated SHARA on all CHC systems in the SV-COMP13 and
SV-COMP15 benchmark suites. Both SV-COMP13 and SV-COMP15 contain the
exact CHC systems used, in directory "clauses". CHC systems in
SV-COMP13 were generated by the SV-COMP maintainers from C programs
using the UFO model checker. CHC systems in SV-COMP15 were generated
by the SV-COMP maintainers from the the NTS benchmark suite using
Eldarica.

---------------------------------------------------------------------

Q3 (Reviews 1, 3): How does the quality of solutions generated by
state-of-the-art techniques compare to those generated by SHARA?

A: Out of our 670 benchmark system, 651 are recursive. Our evaluation
thus indicates that SHARA provides solutions that have quality at
least as good as those of Duality for the purposes of finding
solutions to recursive systems. A more detailed evaluation, in which
we analyze contributions to improvements in performance due to the
time spent to solve each recursion-free system and the number of
recursion-free systems solved, would be interesting to perform, and
will be included in a future version of the paper.

--------------------------------------------------------------------

Q4 (Reviews 1, 3): Is the implementation of SHARA available in order to
reproduce the results?

A: The implementation and benchmarks are available at the following
anonymous URL.
https://www.dropbox.com/s/drh43cj9baf18ej/z3_modified.zip?dl=0

Instructions for running the solver are included within the zip in the
file README.txt.

-------------------------------------------------------------------- 

Q5 (Review 1, 3) The description of existing solvers is incorrect: most
solvers enumerate one derivation at a time and attempt to avoid
enumerating all derivations.

A: We completely agree with this description of existing solvers: this
was the intended reading of our discussion, particularly p4. para 2.

---------------------------------------------------------------------

Q6 (Review 1): The paper presents an algorithm that transforms a
non-linear CHC system to a linear CHC system.

A: SHARA indeed translates a given system S to one in a class that can
be solved tractably, but it does not necessarily translate S to a
system that is linear. SHARA translates a given system to an
equivalent CDD system, but the class of CDD systems strictly contains
the class of linear systems. E.g., the system given in the response to
Q1, and the example system S'[MC] (Sec. 2.2) are non-linear CDD
systems.

---------------------------------------------------------------------
 
Q7 (Review 1): SHARA is guaranteed to be intractable in an
overwhelming number of cases: to generate a CDD expansion, it performs
a step analogous to inlining each function per callsite. In
particular, in Alg. 3, the call to VC on line 10 causes exponential
blowup.

A: To generate a CDD expansion, SHARA indeed may, in some cases, clone
clauses that model a function, if the function is a dependency of
multiple predicates in the body of the same clause. However, SHARA
need not clone every predicate that models a function for each
occurrence in an arbitrary system (or in practice, in most
systems). For example, the program:

g(x) { return x + 1; }
f(x) { if (x >= 0) { res := g(0); } else { res := g(1); } return res;

Can be modeled by system:

res = x + 1 => G(x, res)
G(0, res), x >= 0 => F(x, res)
G(1, res), x < 0 => F(x, res)

The above system is CDD: thus, SHARA would solve it directly without
inlining the definition of G. Avoiding such an inlining can have a
significant consequence on performance if the definition of g() is
large.

In Alg. 3, VC, given a CDD system S, generates a formula of size
linear in S (see Sec. 4.3), so it is not the cause of exponential
blowup. Blowup, if it occurs, is the result of Alg. 2 constructing a
CDD system that is significantly larger than a given system.

---------------------------------------------------------------------
 
Q8 (Review 1): What is the contribution of the proposed approach,
given its high-worst case performance?

A: Previous work has established that solving recursion-free Horn
Claues over integer linear arithmetic is co-NEXPTIME ([14],
Sec. 5). Thus, finding a solution that performs well in general is
infeasible.

The main conceptual contribution of our work is to identify that the
class of CDD systems can be solved with a polynomial number of queries
to a theorem prover. The main practical contribution of our work is to
demonstrate that realistic benchmarks can be translated to CDD systems
that are often much smaller than their worst-case bound on size.

-------------------------------------------------------------------- 

Q9 (Review 1): SHARA should be compared to a previous approach [KGS14]
that solves a given recursion-free CHC system with a polynomial number
of queries. SHARA, given the example program and property in that
paper, would generate systems that are exponentially larger.

A: [KGS14] indeed addresses a relevant problem. However, The approach
proposed in [KGS14] only satisfies a polynomial bound when applied to
Boolean programs. [KGS14] also extends the proposed verifier from
Boolean programs to those that use linear arithmetic. Because the
verifier for linear arithmetic relies on quantifier elimination, it is
not clear if such an approach can be extended to richer theories that
support interpolation, such as the combination of linear arithmetic
with uninterpreted functions.

Consider the following encoding of the program and property from the
paper:

T(m, m'), D(m', m'''), D(m'', m''') => M(m, m''') (1)
t<=0 => T(t, t) (2)
T(t', t''), t > 0, t' = t - 2, t''' = t'' + 1 => T(t, t''') (3)
d' = d - 1 => D(d, d') (4)
m' < 2m + 4 => false (5)

Consider the family of recursion-free CHC systems in which the i-th
system is constructed from i occurences of clause (3). Each system in
the family is not CDD, because it contains a single instance of rule
(1), which contains two occurrences of relational predicate
D. However, the (unique) minimal CDD expansion of each system in the
family is identical except for the fact that it contains two copies of
relational predicate D. Thus the sizes of the CDD expansion of the
i-th system in the family is linear in terms of the size of the i-th
system.

-------------------------------------------------------------------- 

Q10 (Review 1): SHARA should be compared to a previous approach that
has been implemented for solving recursion-free CHC systems
[HB12]. SHARA, given the running example in that paper would generate
systems that are exponentially larger.

A: [HBS12] indeed addresses a relevant problem; the approach proposed
in [HB12] resembles SHARA, in that it uses interpolation to solve
CHC's over theories.

However, the class of systems of non-Boolean theories addressed in
[HB12] is the class of "timed pushdown systems" ([HB12, Sec. 5]), a
subclass of CHC systems with the theory of linear real
arithmetic. Thus, in principle, SHARA and [HB12] are applicable to
distinct classes of CHC systems. In practice, there were not common
benchmarks in SV-COMP on which we could compare SHARA and [HB12].

All families of unwindings constructed from n applications of the
recursive clauses in the example in HB12 are of size linear in n, and
are CDD. E.g., consider the family of systems:

R[0](0, 0, 0, 0)
...
T[i](2, 3, Y1, Y2, Y1)
R[i](L, M, Y1, Y2), T[i](L, L', Y1, Y2, Y1') => R[i + 1](L', M, Y1', Y2)
...
R[n](2, 2, Y1, Y2) => false

Each system in the family is CDD.

-------------------------------------------------------------------- 

Q11 (Review 1) There does not appear to be a significant difference
between SHARA and existing work that computes nested interpolants
using multiple interpolation queries [8].

A: SHARA is indeed similar to the approach proposed in [8] in that
both approaches construct a solution from the result of interpolation
queries. However, the solver proposed in [8] can only be applied to
CHC systems in which each relational predicate is the head of at most
one clause. SolveCDD, used in SHARA, can be applied to CDD systems;
the class of CDD systems strictly contains the class considered in
[8].

-------------------------------------------------------------------- 

Q12 (Review 1) What is the semantics of uninterpreted functions in
constraints? Should they be universally quantified?

A: Yes: the semantics matches that adopted by other solvers for CHC
systems over a theory that includes uninterpreted functions.

-------------------------------------------------------------------- 

Q13 (Review 2): What is the complexity of SHARA for solving a given CDD
system?

A: SHARA issues a number of theorem prover queries that is linear in
the number of clauses in the given system. The size of the formula in
each query is of size bounded linearly in the sum of the sizes of the
constraints in all clauses in the system.

The cost can be derived by a direct analysis of SolveCDD (Alg. 3); we
will provide a more detailed cost and complexity analysis in a future
version of the paper.

-------------------------------------------------------------------- 

Q14 (Review 2): Does the expansion algorithm change the complexity of
solving clauses?

A: This is an interesting question. While different algorithms can
generate expansions of different sizes, they cannot change the
structure of the first-order constraints in each clause, by the
definition of an expansion (Defn. 6). As a result, the complexity of
solving each expansion of a fixed system is determined by the number
of clauses in the system.

-------------------------------------------------------------------- 

Q15 (Review 2): is there a meaningful relationship between solving
times of minimal and non-minimal expansions?

A: This is an interesting question, although there does not appear to
be a relationship between the times required to solve them other than
what is implied by the relationship of their sizes.

-------------------------------------------------------------------- 

Q16 (Review 2): The paper should include additional information
regarding its evaluation.

Out of all benchmark systems found in the editions of SV-COMP, 99 have
a counter-derivation, 328 do not (i.e., have a higher-order solution),
nineteen caused SHARA to timeout, and 224 caused the solvers to return
the value "unknown." Such benchmarks were defined over a theory not
supported by the solvers, e.g. non-linear arithmetic.

Of the nineteen cases on which SHARA timed out, Duality determined
that nine had counter-derivations, three do not, timed out on six, and
returned unknown on one. Duality timed out on eleven cases total. Of
those, SHARA determined that three had a counter-derivation, two did
not, and timed out on the remaining six.

The number of relational predicates in the systems range from three to
293, with an average of eight per system. The number of clauses range
from three to 1,022, with an average of 17. Among the constraint
formulas that occur in each clause, the number of variables that occur
in a formula range from one to 4,819, with an average number of
variables of 4,476.

The ratios of the number of clauses in each original non-recursive
system solved to the number of clauses in its CDD expansion ranged
from one to 19, with an average of 1.73.
