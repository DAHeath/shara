\section{Related Work}
\label{sec:related-work}
% different classes of CHC solvers:
A significant body of previous work has presented solvers for
different classes of Constrained Horn Clauses, or finding inductive
invariants of programs that correspond to solutions of CHCs.
% solving linear systems:
\impact attempts to verify a given sequential procedure, which
corresponds to solving a recursive linear CHC
system~\cite{mcmillan06}.
%
\impact attempts to verify a given procedure by iteratively selecting
paths and synthesizing invariants for each path.
%
Such an approach corresponds to iteratively and selecting and solving
derivations of a corresponding linear CHC system.

% interprocedural verification:
Previous work also proposed a verifier for recursive
programs~\cite{heizmann10}.
%
The proposed approach selects interprocedural paths of a program and
synthesizes invariants for each as nested interpolants.
%
Such an approach corresponds to attempting to solve a recursive CHC
system $S$ by selecting derivation trees of $S$
and solving each tree.

% solving recursive systems:
Previous work has proposed solvers for recursive systems that, given a
system $S$, attempt to solve $S$ by generating and
solving a series of recursion-free unwindings of $S$.
%
In particular, \eldarica attempts to solve each unwinding
$S'$ by reducing to and solving body-disjoint systems~\cite{rummer13a,rummer13b}.
%
\duality attempts to avoid solving all derivation-trees (i.e
body-disjoint system) by using lazy annotation~\cite{bjorner13}.
%
Other optimizations selects derivation trees to solve using symbolic
symbolic analogs of Prolog evaluation with
tabling~\cite{jaffar09,mcmillan14}.
%

\whale attempts to verify sequential recursive programs by generating
and solving hierarchical programs, which correspond to recursion-free CHC
systems~\cite{albarghouthi12b}.
%
To solve a particular recursion-free system, \whale solves a linear
inlining of the input using a procedure named
\vinta~\cite{albarghouthi12a}.
%
In general, the linear inlining may be exponentially larger than the
input.

\sys is similar to the recursion free CHC approaches given above in
that it reduces the problem to solving a CHC system in a
directly-solvable class.
%
\sys is distinct in that it reduces to solving Clause-Dependent
Disjoint (CDD) systems.
%
As discussed in \autoref{sec:overview}, the class of CDD systems if a
superset of classes used by the approaches above. And CDD systems can
also be solved directly.

\sys solves general CHC systems using the same strategy as proposed by
the above approaches.
%
Specifically, it solves a series of recursion-free unwindings of the
original system, and tries to synthesize a general solution from the
recursion-free solutions.

Previous work describes solvers for non-linear Horn clauses over
particular theories.
%
In particular, verifiers have been proposed for recursion-free systems
over the theory of linear arithmetic~\cite{komuravelli14}.
%
Because the verifier relies on quantifier elimination, it is not clear
if it can be extended to richer theories that support interpolation,
such as the combination of linear arithmetic with uninterpreted
functions.
%
Other work describes a solver for the class of \emph{timed pushdown
systems}, a subclass of CHC systems over the theory of linear real
arithmetic~\cite{hoder12}.
%
Unlike these approaches, \sys can solve systems over any theory that
supports interpolation.

% DAG inlining:
DAG inlining attempts to generate compact verification conditions for
hierarchical programs~\cite{lal-qadeer15}.
%
\sys attempts to solve recursion-free CHC systems by attempting to
reduce them to compact CDD systems.
%
Because hierarchical programs and recursion-free CHC systems are
closely related, algorithms that operate on hierarchical programs
correspond to algorithms that operate on recursion-free Horn Clauses.
%
However, it is not apparent that such algorithms can be used directly
to synthesize solutions for recursion-free CHC systems.
