% intro:
\section{Introduction}
\label{sec:intro}
% context, problem defn:
Many critical problems in program verification can be reduced to
solving systems of Constrained Horn Clauses (CHCs), a class of
logic-programming
problems~\cite{bjorner13,flanagan03,rummer13a,rummer13b}.
%
A CHC is a logical implication where the antecedent is a conjunction
of uninterpreted predicates with a fact in a background
theory and the consequent is an uninterpreted predicate. 
%
In the context of a CHC we call the antecedent the body and the
consequent the head.  A CHC system is a set of CHCs. 
%
The goal of a CHC solving problem is to find suitable interpretations
for each predicate such that each CHC is logically
consistent in isolation.\QZ{re-write this based on other papers}

% introduce the problem of solving recursion-free systems:
In this work we focus on the subclass of CHC systems which are known
as \emph{recursion-free}. In a recursion-free CHC system, the
derivation of each predicate will not contain
itself. \QZ{\DAH{I still think we need a small example here}}
%
Recursion-free CHC systems are an important subclass for two reasons.
%
First, recursion-free systems can be used to model safety properties
for hierarchical programs~\cite{lal-qadeer15,lal-qadeer-lahiri12}
(programs with only bounded iteration and recursion).



%
Second and most importantly, A well-known approach for solving a general CHC
system can reduce to solving a sequence of recursion-free
systems \QZ{reference}.
%
Many solvers attempt to synthesize the solution of the original system 
by using the solutions of constructed recruion-free system~\cite{bjorner13}.
%
Because of this, the performance of solving general CHC system is heavily reliant on the 
performance of the solving recursion-free CHC system.
%


% current general techniques for solving recursion-free systems
Typically, recursion-free CHC systems are not solved directly.
%
Instead, they are reduced to a more specific subclass of
recursion-free CHC system.
%
These classes include those of
\emph{body disjoint} (or \emph{derivation tree})
systems~\cite{heizmann10,bjorner13,mcmillan14,rummer13a,rummer13b} and
of \emph{linear} systems~\cite{albarghouthi12a}.
%
We will discuss these classes in \autoref{sec:overview} and
\autoref{sec:related-work}.
%
Such classes can be solved by issuing
\emph{interpolation queries} for uninterpreted predicate and 
each constrains shows only one time in the interpolation query.
%
We
refer such class as \emph{directly solvable}.

% Time complexity
In general, solving a recursion-free CHC system for 
propositional logic and theory of linear integer arithmetic is
co-NEXPTIME-complete~\cite{rummer13b}.
%
In contrast, solving a directly solvable system with the same logic and theories
is in co-NP~\cite{rummer13b}.
%
Therefore, the performance of solving a recurion-free system is highly reliant on the
size of the directly solvable systems it is reduced to.

% contribution of this paper: CDD systems:
The first contribution of this paper is the introduction of a novel
class of directly solvable systems that we refer to as
\emph{Clause-Dependence Disjoint} (CDD).
%
The class consists of all recursion-free CHC systems such that each
clause in the system has at most one dependency on the same relational
predicate.\QZ{repharse this}
%
The key characteristic of this class is that CDD systems are often
smaller than equivalent systems in other directly solvable classes,
and therefore solving recursion free systems by rewriting them in CDD
form is often less computationally expensive.

% a new solver
The second contribution of this paper is a solver for CHC systems,
named \sys.
%
Given a recursion-free system $S$, \sys reduces the problem
of solving $S$ to solving an equivalent CDD system
$S'$.
%
In the worst case, it is possible that the size of $S'$ may be
exponential in the size of $S$.
%
However, empirically we have found that the size of $S'$ is usually
close enough to the size of $S$ that \sys often outperforms the best
known CHC solvers.
%
The procedure implemented in \sys is a generalization of existing
techniques that synthesize compact verification conditions for
hierarchical programs~\cite{flanagan01,lal-qadeer15}.
%
Given a general (possibly recursive) CHC system, \sys solves a
sequence of recursion-free systems.
%
Each subsystem is a bounded unwinding of the original system. \sys
attempts to combine the solutions of these recursion-free systems to
synthesize a soltuion to the original problem, as has been proposed
in previous work~\cite{rummer13b}.

% experience:
We implemented \sys within the \duality CHC solver~\cite{bjorner13},
which is implemented within the \zthree automatic theorem
prover~\cite{moura08}.
%
We evaluated the effectiveness of \sys on standard benchmarks drawn
from SVCOMP15~\cite{svcomp15}.
%
The results indicate that in a strong majority of cases,
\sys performs better than modern solvers.
%
Futhermore, the results indicate that combining the strengths of \sys
with that of other existing approaches (as discussed in
\autoref{sec:evaluation}) is a promising direction for the future of
CHC solving.

% paper outline:
The rest of this paper is organized as follows.
%
\autoref{sec:overview} illustrates the operation of \sys on a
recursion-free CHC system.
%
\autoref{sec:background} reviews technical work on which \sys is
based.
%
\autoref{sec:approach} describes \sys in technical detail.
%
\autoref{sec:evaluation} gives the results of our empirical evaluation
of \sys.
%
\autoref{sec:related-work} compares \sys to related work.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
