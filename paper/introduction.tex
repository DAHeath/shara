% intro:
\section{Introduction}
\label{sec:intro}
% context, problem defn:
Many critical problems in program verification can be reduced to
solving systems of Constrained Horn Clauses (CHCs), a class of
logic-programming
problems~\cite{bjorner13,flanagan03,rummer13a,rummer13b}.
%
A CHC is a logical implication where the antecedent is a conjunction
of uninterpreted relational predicates with a fact in a background
theory and the consequent is an uninterpreted relational predicate. In
the context of a CHC we call the antecedent the body and the
consequent the head.  A CHC system is a set of CHCs.
%
The goal of a CHC solving problem is to find suitable interpretations
for each relational predicate such that each CHC is logically
consistent in isolation.

% introduce the problem of solving recursion-free systems:
In this work we focus on the subclass of CHC systems which are known
as \emph{recursion-free}. In a recursion-free CHC system, the
derivation of each relational predicate will contain no references to
itself. \QZ{\DAH{I still think we need a small example here}}
%
Recursion-free CHC systems are an important subclass for two reasons.
%
First, recursion-free systems can be used to model safety properties
for hierarchical programs~\cite{lal-qadeer15,lal-qadeer-lahiri12}
(programs with only bounded iteration and recursion).
%
Second and most importantly, the task of solving a general CHC
system can reduce to the task of solving a sequence of recursion-free
systems \QZ{reference}.

Many \QZ{more references? Or remove many.} modern solvers generate
a sequence such that each subsystem is a bounded unwinding of the
input system. These solvers either attempt to show that the solution to a
given subsystem generalizes to the original system or generate a
larger subsystem for the next iteration~\cite{bjorner13}.
%
Since such solvers inspect recursion-free systems in an iterative
loop, they are heavily reliant on the performance of the underlying
recursion-free solver.
%
% current general techniques for solving recursion-free systems
Typically, even recursion-free CHC systems are not solved directly.
Instead, they are reduced to a more specific subclass of
recursion-free CHC system.
%
These classes include those of
\emph{body disjoint} (or \emph{tree structure})
systems~\cite{heizmann10,bjorner13,mcmillan14,rummer13a,rummer13b} and
of \emph{linear} systems~\cite{albarghouthi12a}.
%
We will discuss these classes in \autoref{sec:overview} and
\autoref{sec:related-work}.
%
Such classes have proved practical because a solver can find
suitable definitions for relational predicates by issuing
\emph{interpolation queries}.
%
When a class of CHC systems can be solved by interpolation queries, we
say the class is \emph{directly solvable}.

% Time complexity
In general, solving a recursion-free CHC system whose facts are
restricted to the theory of linear integer arithmetic is
co-NEXPTIME-complete~\cite{rummer13b}.
%
In contrast, solving a directly solvable system with the same theories
is in co-NP~\cite{rummer13b}.
%
Therefore, the performance of a CHC solver is highly reliant on the
size of the directly solvable systems it produces.

% contribution of this paper: CDD systems:
The first contribution of this paper is the introduction of a novel
class of directly solvable systems that we refer to as
\emph{Clause-Dependence Disjoint} (CDD).
%
The class consists of all recursion-free CHC systems such that each
clause in the system has at most one dependency on the same relational
predicate.
%
The key characteristic of this class is that CDD systems are often
smaller than equivalent systems in other directly solvable classes,
and therefore solving recursion free systems by rewriting them in CDD
form is often less computationally expensive.

% a new solver
The second contribution of this paper is a solver for CHC systems,
named \sys.
%
Given a recursion-free system $S$, \sys reduces the problem
of solving $S$ to solving an equivalent CDD system
$S'$.
%
In the worst case, it is possible that the size of $S'$ may be
exponential in the size of $S$.
%
However, empirically we have found that the size of $S'$ is usually
close enough to the size of $S$ that \sys often outperforms the best
known CHC solvers.
%
The procedure implemented in \sys is a generalization of existing
techniques that synthesize compact verification conditions for
hierarchical programs~\cite{flanagan01,lal-qadeer15}.
%
Given a general (possibly recursive) CHC system, \sys solves a
sequence of recursion-free systems.
%
Each subsystem is a bounded unwinding of the original system. \sys
attempts to combine the solutions of these recursion-free systems to
synthesize a soltuion to the original problem, as has been proposed
in previous work~\cite{rummer13b}.

% experience:
We implemented \sys within the \duality CHC solver~\cite{bjorner13},
which is implemented within the \zthree automatic theorem
prover~\cite{moura08}.
%
We evaluated the effectiveness of \sys on standard benchmarks drawn
from SVCOMP15~\cite{svcomp15}.
%
The results indicate that in a strong majority of cases,
\sys performs better than modern solvers.
%
Futhermore, the results indicate that combining the strengths of \sys
with that of other existing approaches (as discussed in
\autoref{sec:evaluation}) is a promising direction for the future of
CHC solving.

% paper outline:
The rest of this paper is organized as follows.
%
\autoref{sec:overview} illustrates the operation of \sys on a
recursion-free CHC system.
%
\autoref{sec:background} reviews technical work on which \sys is
based.
%
\autoref{sec:approach} describes \sys in technical detail.
%
\autoref{sec:evaluation} gives the results of our empirical evaluation
of \sys.
%
\autoref{sec:related-work} compares \sys to related work.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
