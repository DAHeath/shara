We thank the reviewers for their detailed comments. Responses are
included below, where each summarized comment is labeled with the
reviews that contained it. Each of the points will be addressed in a
future version of the paper.

-------------------------------------------------------------------- 

Q2 (Review 1): What is the meaning of "Query_S that is the dependency
of no relation predicate", page 8?

A: An alternative phrasing is that Query_S is not the dependency of
any relational predicate.

---------------------------------------------------------------------

Q3 (Review 1): Does Defnition 6 imply that the dependency graph of
each body is a forest?

A: Not necessarily; the following system is CDD:

(1) R1 => R0
(2) R3 => R1
(3) R4 => R1
(4) R5 => R3
(5) R5 => R4

However, the dependency graph of the body of clause (1) is a DAG.

--------------------------------------------------------------------

Q4 (Review 1): What is Use[R] in "Constructing the Counterexample
Characterization of a CDD"? In this section, why is T used as a
metavariable for an arbitrary CHC system?

A: Use[R] is a boolean predicate to indicate if relational predicate R
occurs in a hypothetical counterexample. The constraints on it are
described in detail in paragraph "Constructing the Counterexample
Characterization of a CDD", page 10.

We have used a fresh variable T so that the counterexample
characterization can be defined once, in general, for an arbitrary
system and instantiated for multple systems, each introduced in
"Constructing the post constraint of a relational predicate."

The variable S is fixed prior to this section as an arbitrary CHC
system to be solved.

-------------------------------------------------------------------- 

Q5 (Review 1): Can the pre-constraint and post-constraint be
characterized precisely?

A: After giving the intuition behind each constraint, we have given
the formula itself at the end of the paragraph.

---------------------------------------------------------------------

Q1 (Review 1): Was the Expand procedure introduced in previous work?

A: We have included the definition of Expand in Appendix A.

-------------------------------------------------------------------------

Q5 (Review 1): Why can SHARA not parse benchmarks generated by SeaHorn?

A: SHARA correctly parses benchmarks generated by SeaHorn, and these
benchmarks are the subject of our evaluation. The Eldarica CHC solver
[20], a solver to which we attempted to compare SHARA, could not parse
such systems.

---------------------------------------------------------------------------

Q6 (Review 2): Why did you evaluate SHARA compared only to Duality?
Did you try to compare SHARA to other tools?

A: We primarily evaluated SHARA compared to Duality because it is the
most reliable competitive solver that we could find. We also attempted
to compare SHARA to Eldarica on benchmarks generated by SeaHorn;
Eldarica failed to parse such benchmarks. Previous results strongly
indicate that Duality can consistently and significantly outperform
SeaHorn [18]. These were confirmed by our own informal experiments,
which we can report in a future version of this paper.

---------------------------------------------------------------------
 
Q7 (Review 2): The paper is missing a conclusion and discussion of
potential optimizations as future work.

A: The current paper speculates one potential optimization in Sec. 5,
final paragraph. We will include a more extensive discussion in a
future version of the paper.
   
---------------------------------------------------------------------
 
Q8 (Review 3): The paper is in a specialized area of verification that
is unlikely to be interesting to the SAT audience.

A: While we have only discussed one relatively simple example of a
safety verification problem formulated as a CHC system, previous work
has established that CHC systems can formulate an extremely expressive
set of safety-verification problems, including safety of sequential
recursive programs, safety of concurrent programs, and
information-flow security of programs.

CHC solving, which in general is defined as an instance of Constraint
Programming over SMT theories independent of any verification problem,
has also been shown to be useful in modeling a variety of systems,
automata, and concurrent processes [Jaffar], and in knowledge
representation within AI [Brachman].

While the expressive power of CHC systems has been well-studied,
effective techniques for solving them, particularly those based on
interpolation over SMT theories, are relatively new. We believe that
just as techniques communicated between the SAT/SMT and verification
communities for solving SAT and SMT formulas have significantly
strengthened both fields, both communities will benefit from the
mutual study of this branch of Constraint Programming.

---------------------------------------------------------------------

References:

Brachman, Ronald J., Hector J. Levesque, and Raymond Reiter. Knowledge
representation. MIT press, 1992.

Jaffar, Joxan. "A CLP approach to modelling systems." Lecture Notes in
Computer Science (2004).
